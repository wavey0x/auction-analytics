#!/usr/bin/env bash
set -euo pipefail

# Repairs common post-restore issues:
# 1) Adds GENERATED BY DEFAULT AS IDENTITY to integer PK columns missing default/identity.
#    Also bumps sequences to max(id)+1.
# 2) Optional: Drops NOT NULL on non-PK columns that have no default (opt-in flag).
#
# Usage:
#   DATABASE_URL=postgres://... ./scripts/repair_primary_key_identities.sh [--schema=public] [--drop-not-null-missing-defaults]
#   # or
#   PROD_DATABASE_URL=postgres://... ./scripts/repair_primary_key_identities.sh [--schema=public] [--drop-not-null-missing-defaults]
#
# Flags:
#   --schema=NAME                    Limit operations to a schema (default: public)
#   --drop-not-null-missing-defaults Drop NOT NULL for non-PK, non-identity columns that lack defaults

PSQL_BIN="${PSQL_BIN:-psql}"
SCHEMA="public"
DROP_NN="no"

for arg in "$@"; do
  case "$arg" in
    --schema=*) SCHEMA="${arg#*=}" ;;
    --drop-not-null-missing-defaults) DROP_NN="yes" ;;
  esac
done
TARGET_URL="${DATABASE_URL:-${PROD_DATABASE_URL:-}}"

if [[ -z "${TARGET_URL}" ]]; then
  echo "ERROR: set DATABASE_URL or PROD_DATABASE_URL" >&2
  exit 1
fi

echo "[repair_pk_identities] Using URL=${TARGET_URL%%\?*}"
echo "[repair_pk_identities] Schema: $SCHEMA"

"$PSQL_BIN" "$TARGET_URL" -v ON_ERROR_STOP=1 -v SCHEMA="$SCHEMA" <<'SQL'
SET search_path TO :SCHEMA, pg_catalog;
DO $do$
DECLARE
  r record;
  seq_name text;
  max_id bigint;
BEGIN
  -- 1) Primary-key integer columns missing identity/default
  FOR r IN
    SELECT c.table_schema, c.table_name, c.column_name
    FROM information_schema.columns c
    JOIN information_schema.table_constraints tc
      ON tc.table_schema=c.table_schema
     AND tc.table_name=c.table_name
     AND tc.constraint_type='PRIMARY KEY'
    JOIN information_schema.key_column_usage k
      ON k.table_schema=tc.table_schema
     AND k.table_name=tc.table_name
     AND k.constraint_name=tc.constraint_name
     AND k.column_name=c.column_name
    WHERE c.table_schema = current_schema
      AND c.udt_name IN ('int2','int4','int8')
      AND (c.column_default IS NULL OR c.column_default = '')
      AND c.is_identity = 'NO'
      AND c.table_schema NOT IN ('pg_catalog','information_schema')
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I ADD GENERATED BY DEFAULT AS IDENTITY',
                   r.table_schema, r.table_name, r.column_name);

    SELECT pg_get_serial_sequence(format('%I.%I', r.table_schema, r.table_name), r.column_name)
      INTO seq_name;

    IF seq_name IS NOT NULL THEN
      EXECUTE format('SELECT COALESCE(MAX(%I),0) FROM %I.%I',
                     r.column_name, r.table_schema, r.table_name)
        INTO max_id;
      EXECUTE format('SELECT setval(%L, %s, true)', seq_name, (max_id + 1)::text);
    END IF;

    RAISE NOTICE 'Added identity to %.%.% (seq: %)',
      r.table_schema, r.table_name, r.column_name, seq_name;
  END LOOP;

  -- 2) Fallback: integer columns literally named "id" (NOT NULL, no default, not identity), even if not PK
  FOR r IN
    SELECT c.table_schema, c.table_name, c.column_name
    FROM information_schema.columns c
    LEFT JOIN (
      SELECT tc.table_schema, tc.table_name, k.column_name
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage k
        ON k.table_schema=tc.table_schema
       AND k.table_name=tc.table_name
       AND k.constraint_name=tc.constraint_name
      WHERE tc.constraint_type='PRIMARY KEY'
    ) pk
      ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name
    WHERE c.table_schema = current_schema
      AND c.column_name='id'
      AND c.is_nullable='NO'
      AND c.udt_name IN ('int2','int4','int8')
      AND (c.column_default IS NULL OR c.column_default = '')
      AND c.is_identity='NO'
      AND pk.column_name IS NULL -- not already covered by PK branch
      AND c.table_schema NOT IN ('pg_catalog','information_schema')
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I ADD GENERATED BY DEFAULT AS IDENTITY',
                   r.table_schema, r.table_name, r.column_name);

    SELECT pg_get_serial_sequence(format('%I.%I', r.table_schema, r.table_name), r.column_name)
      INTO seq_name;

    IF seq_name IS NOT NULL THEN
      EXECUTE format('SELECT COALESCE(MAX(%I),0) FROM %I.%I',
                     r.column_name, r.table_schema, r.table_name)
        INTO max_id;
      EXECUTE format('SELECT setval(%L, %s, true)', seq_name, (max_id + 1)::text);
    END IF;

    RAISE NOTICE 'Added identity to %.%.% (seq: %) [id fallback]',
      r.table_schema, r.table_name, r.column_name, seq_name;
  END LOOP;
END $do$;
SQL

echo "[repair_pk_identities] Completed."

if [[ "$DROP_NN" == "yes" ]]; then
  echo "[repair_pk_identities] Dropping NOT NULL where no defaults exist (non-PK, non-identity) in schema '$SCHEMA'..."
  "$PSQL_BIN" "$TARGET_URL" -v ON_ERROR_STOP=1 -v SCHEMA="$SCHEMA" <<'SQL'
SET search_path TO :SCHEMA, pg_catalog;
DO $do$
DECLARE
  r record;
BEGIN
  FOR r IN
    WITH pk_cols AS (
      SELECT tc.table_schema, tc.table_name, k.column_name
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage k
        ON k.table_schema=tc.table_schema AND k.table_name=tc.table_name AND k.constraint_name=tc.constraint_name
      WHERE tc.constraint_type='PRIMARY KEY'
    )
    SELECT c.table_schema, c.table_name, c.column_name
    FROM information_schema.columns c
    LEFT JOIN pk_cols pk
      ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name
    WHERE c.table_schema = current_schema
      AND c.is_nullable='NO'
      AND (c.column_default IS NULL OR c.column_default = '')
      AND c.is_identity='NO'
      AND pk.column_name IS NULL
      AND c.table_schema NOT IN ('pg_catalog','information_schema')
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I DROP NOT NULL',
                   r.table_schema, r.table_name, r.column_name);
    RAISE NOTICE 'Dropped NOT NULL on %.%.%', r.table_schema, r.table_name, r.column_name;
  END LOOP;
END $do$;
SQL
  echo "[repair_pk_identities] NOT NULL drops completed."
fi
