#!/usr/bin/env bash
set -euo pipefail

# Adds GENERATED BY DEFAULT AS IDENTITY to integer primary key columns
# that are NOT NULL and currently lack a default/identity. Also bumps
# the new sequence to max(id)+1 to avoid conflicts.
#
# Usage:
#   DATABASE_URL=postgres://... ./scripts/repair_primary_key_identities.sh
#   # or
#   PROD_DATABASE_URL=postgres://... ./scripts/repair_primary_key_identities.sh

PSQL_BIN="${PSQL_BIN:-psql}"
TARGET_URL="${DATABASE_URL:-${PROD_DATABASE_URL:-}}"

if [[ -z "${TARGET_URL}" ]]; then
  echo "ERROR: set DATABASE_URL or PROD_DATABASE_URL" >&2
  exit 1
fi

echo "[repair_pk_identities] Using URL=${TARGET_URL%%\?*}"

"$PSQL_BIN" "$TARGET_URL" -v ON_ERROR_STOP=1 <<'SQL'
DO $$
DECLARE
  r record;
  seq_name text;
  max_id bigint;
BEGIN
  -- 1) Primary-key integer columns missing identity/default
  FOR r IN
    SELECT c.table_schema, c.table_name, c.column_name
    FROM information_schema.columns c
    JOIN information_schema.table_constraints tc
      ON tc.table_schema=c.table_schema
     AND tc.table_name=c.table_name
     AND tc.constraint_type='PRIMARY KEY'
    JOIN information_schema.key_column_usage k
      ON k.table_schema=tc.table_schema
     AND k.table_name=tc.table_name
     AND k.constraint_name=tc.constraint_name
     AND k.column_name=c.column_name
    WHERE c.udt_name IN ('int2','int4','int8')
      AND (c.column_default IS NULL OR c.column_default = '')
      AND c.is_identity = 'NO'
      AND c.table_schema NOT IN ('pg_catalog','information_schema')
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I ADD GENERATED BY DEFAULT AS IDENTITY',
                   r.table_schema, r.table_name, r.column_name);

    SELECT pg_get_serial_sequence(format('%I.%I', r.table_schema, r.table_name), r.column_name)
      INTO seq_name;

    IF seq_name IS NOT NULL THEN
      EXECUTE format('SELECT COALESCE(MAX(%I),0) FROM %I.%I',
                     r.column_name, r.table_schema, r.table_name)
        INTO max_id;
      EXECUTE format('SELECT setval(%L, %s, true)', seq_name, (max_id + 1)::text);
    END IF;

    RAISE NOTICE 'Added identity to %.%.% (seq: %)',
      r.table_schema, r.table_name, r.column_name, seq_name;
  END LOOP;

  -- 2) Fallback: integer columns literally named "id" (NOT NULL, no default, not identity), even if not PK
  FOR r IN
    SELECT c.table_schema, c.table_name, c.column_name
    FROM information_schema.columns c
    LEFT JOIN (
      SELECT tc.table_schema, tc.table_name, k.column_name
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage k
        ON k.table_schema=tc.table_schema
       AND k.table_name=tc.table_name
       AND k.constraint_name=tc.constraint_name
      WHERE tc.constraint_type='PRIMARY KEY'
    ) pk
      ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name
    WHERE c.column_name='id'
      AND c.is_nullable='NO'
      AND c.udt_name IN ('int2','int4','int8')
      AND (c.column_default IS NULL OR c.column_default = '')
      AND c.is_identity='NO'
      AND pk.column_name IS NULL -- not already covered by PK branch
      AND c.table_schema NOT IN ('pg_catalog','information_schema')
  LOOP
    EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I ADD GENERATED BY DEFAULT AS IDENTITY',
                   r.table_schema, r.table_name, r.column_name);

    SELECT pg_get_serial_sequence(format('%I.%I', r.table_schema, r.table_name), r.column_name)
      INTO seq_name;

    IF seq_name IS NOT NULL THEN
      EXECUTE format('SELECT COALESCE(MAX(%I),0) FROM %I.%I',
                     r.column_name, r.table_schema, r.table_name)
        INTO max_id;
      EXECUTE format('SELECT setval(%L, %s, true)', seq_name, (max_id + 1)::text);
    END IF;

    RAISE NOTICE 'Added identity to %.%.% (seq: %) [id fallback]',
      r.table_schema, r.table_name, r.column_name, seq_name;
  END LOOP;
END $$;
SQL

echo "[repair_pk_identities] Completed."
